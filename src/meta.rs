
pub type ConnectionID = usize;
pub type WindowID = usize;

// TODO: Consider how specification of the arguments for commands ought to work, or if it ought
// to be a thing in the first place.
pub type Command = String;

/// Fragments of data about something that's happened--user input, text sent by a remote server,
/// etcetera.  They are generated by code running in threads, which are managed by some object
/// implementing the EventManager trait below.
#[derive(Debug)]
pub enum Event {
    UserCommand { cmd: Command },
    // We will want to be able to discriminate which _window_ in the UI a line of text came from,
    // not which connection it should go to.  (That is, the UI doesn't know anything about the
    // mapping of windows to connections.)
    UserInput { line: String, which: WindowID },

    ServerText { line: String, which: ConnectionID },
    ConnectionStart { which: ConnectionID },
    ConnectionEnd { which: ConnectionID, reason: String },

    QuitRequest,
}

/// Objects that generate Events by blocking on I/O or other similar activities in a thread impl
/// this trait.  The generic parameter refers to the data type that is passed back, internally,
/// from the listening thread to the callback.
pub trait EventSource<T> {
    /// Callback function to handle a chunk of raw data from the listener thread and return any
    /// relevant Events generated.  If no Events are generated, just return vec![].
    fn process<T>(&mut self, data: T) -> Vec<Event>;

    /// Return a Listener object containing the required state and functionality to listen for data
    /// in another thread.
    fn get_listener<T>(&mut self) -> Listener<T>;
}

/// Object encapsulating the state and functionality for listening for new data, I/O, file writes,
/// or whatever else.  This thread should perform only minimal processing; it must return its data
/// by pushing to the `channel` as soon as reasonably possible.
pub trait Listener<T> {
    fn run(&mut self, channel: std::sync::mpsc::Sender<Event>);
}

/// A type encapsulating inter-thread channels.  This is present mainly to allow various sources of
/// data sent along one channel to be disambiguated by the EventManager, but it also abstracts the
/// specific API used.  The type T is the data to be sent along the channel and the type I defines
/// what shall be used for the unique identifier.
pub trait Channel<I, T>
    where I: Sync + Send,
          T: Sync + Send {
    /// Send a message along the channel.  This routine should never be implemented in such a
    /// fashion that it blocks.  It is expected to panic if you call it on the RX end of the
    /// channel.
    fn send(&mut self, value: T) -> Result<(), ()>;

    /// Receive the next message from the channel, or block until a message arrives if none are
    /// available currently.  This function is expected to panic if you call it on the TX end of the
    /// channel.
    fn recv(&mut self) -> (I, T);

    /// Construct a new Channel object.
    fn new(&mut self, tag: I) -> Self;

    /// Return a clone of the channel, suitable for send()ing data along.
    fn get_tx(&mut self) -> Self;
}

/// Trait implemented by an object that manages various sources of Events.
pub trait EventManager {
    fn start_source(&mut self, src: Box<EventSource + Send>);
    fn next_event(&mut self) -> Result<Event, String>;
}

// This object knows about the logistical details of handling UI, like drawing to the screens.
//
// It needs to generate Events, such as when text input is sent from the input pane.  Technically,
// it can react to some inputs on its own and only generate Events for what the rest of the system
// needs to know about.  The problem with impl'ing EventSource on this object is that EventSources
// are consumed and moved into another thread by the EventManager, and this object also needs to be
// sent data from the main thread; to fix this, we generate a subsidiary EventSource object
// instead.
pub trait UserInterface {
    // The way windows work is that any unique named window you try to send text to should be
    // created by the UI code. Which windows are visible at any given time, and how that activity
    // is surface to the user, is the UI code's business.
    fn push_to_window(&mut self, window: String, line: String) -> Result<(), ()>;
    fn register_command(&mut self, c: Command);

    fn listener(&mut self) -> Box<EventSource + Send>;
}

// This type of object knows about servers and contains the low-level logic for connecting and
// listening to a particular sort of MUD server.  It returns a secondary object instead of directly
// impl'ing EventSource for the reasons listed above.
//
// The `address' is provided in a single String with an implementation-defined format to
// accomodate those types of server that may not be able to be satisfied with a traditional
// host/port pair.
pub trait ConnectionInterface {
    fn start_connection(&mut self, address: String) -> Result<ConnectionID, String>;
    fn stop_connection(&mut self, which: ConnectionID) -> Result<(), ()>;
    fn write_to_connection(&mut self, which: ConnectionID, what: String) -> Result<(), ()>;

    fn listener(&mut self) -> Box<EventSource + Send>;
}

