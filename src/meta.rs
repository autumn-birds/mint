use std::cell::RefCell;
use std::rc::Rc;

pub type ConnectionID = usize;
pub type WindowID = usize;

// TODO: Consider how specification of the arguments for commands ought to work, or if it ought
// to be a thing in the first place.
pub type Command = String;

/// Fragments of data about something that's happened--user input, text sent by a remote server,
/// etcetera.  They are generated by code running in threads, which are managed by some object
/// implementing the EventManager trait below.
#[derive(Debug)]
pub enum Event {
    UserCommand { cmd: Command },
    // We will want to be able to discriminate which _window_ in the UI a line of text came from,
    // not which connection it should go to.  (That is, the UI doesn't know anything about the
    // mapping of windows to connections.)
    UserInput { line: String, which: WindowID },

    ServerText { line: String, which: ConnectionID },
    ConnectionStart { which: ConnectionID },
    ConnectionEnd { which: ConnectionID, reason: String },

    /// A serious internal problem, e.g., a listening thread panicked or died.
    InternalError { what: String },
    QuitRequest,
}

/// Objects that generate Events in response to I/O or other similar sources of data, specifically
/// those that do so by listening on one or more threads, implement this trait.  Communication
/// between the thread(s) and the EventSource object proper (which is always owned by the main
/// thread) is assumed to be handled by the implementation in whatever way it sees fit.
pub trait EventSource {
    /// Callback function to handle a chunk of raw data from the listener thread and return any
    /// relevant Events generated.  If no Events are generated, just return vec![].
    fn process(&mut self) -> Vec<Event>;

    /// Return a list of objects representing the state and data required for every individual
    /// listening thread this EventSource wants to run.
    fn get_listeners(&mut self) -> Vec<Box<Listener>>;
}

/// Object encapsulating the state and functionality for listening for new data, I/O, file writes,
/// or whatever else.  This thread should perform only minimal processing; it must return its data
/// by some internal method (probably a Mutex shared by the parent EventSource...)
pub trait Listener: Send {
    /// This method should listen for data, transfer it into the associated EventSource by whatever
    /// synchronization method the implementor chooses, and page the ReadinessPager when either
    /// this has been done and the data needs to be processed (by the EventSource), or an error
    /// occurs.
    fn run(&mut self, flag: Box<ReadinessPager>);
}

/// Object allowing its owner to notify the parent thread that either data has been successfully
/// read and needs to be processed, or an error occurred.
pub trait ReadinessPager: Send {
    /// Notify the thread that data needs to be processed.
    fn ok(&mut self);

    /// Notify the thread of an error.  Provide ideally a human-readable error message.
    fn err(&mut self, why: String);
}

/// Trait implemented by an object that manages various sources of Events.
pub trait EventManager {
    fn start_source(&mut self, src: Rc<RefCell<EventSource>>);
    fn next_event(&mut self) -> Result<Event, String>;
}

// This object knows about the logistical details of handling UI, like drawing to the screens.
//
// It needs to generate Events, such as when text input is sent from the input pane.  Technically,
// it can react to some inputs on its own and only generate Events for what the rest of the system
// needs to know about.  The problem with impl'ing EventSource on this object is that EventSources
// are consumed and moved into another thread by the EventManager, and this object also needs to be
// sent data from the main thread; to fix this, we generate a subsidiary EventSource object
// instead.
pub trait UserInterface {
    // The way windows work is that any unique named window you try to send text to should be
    // created by the UI code. Which windows are visible at any given time, and how that activity
    // is surface to the user, is the UI code's business.
    fn push_to_window(&mut self, window: String, line: String) -> Result<(), ()>;
    fn register_command(&mut self, c: Command);
}

// This type of object knows about servers and contains the low-level logic for connecting and
// listening to a particular sort of MUD server.  It returns a secondary object instead of directly
// impl'ing EventSource for the reasons listed above.
//
// The `address' is provided in a single String with an implementation-defined format to
// accomodate those types of server that may not be able to be satisfied with a traditional
// host/port pair.
pub trait ConnectionInterface {
    fn start_connection(&mut self, address: String) -> Result<ConnectionID, String>;
    fn stop_connection(&mut self, which: ConnectionID) -> Result<(), ()>;
    fn write_to_connection(&mut self, which: ConnectionID, what: String) -> Result<(), ()>;
}

